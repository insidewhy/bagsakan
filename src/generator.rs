use crate::parser::{EnumInfo, EnumValue, InterfaceInfo, PropertyInfo, ValidatorFunction};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::Path;

pub struct ValidatorGenerator {
    interfaces: HashMap<String, InterfaceInfo>,
    enums: HashMap<String, EnumInfo>,
    use_js_extensions: bool,
}

impl ValidatorGenerator {
    pub fn new(
        interfaces: HashMap<String, InterfaceInfo>,
        enums: HashMap<String, EnumInfo>,
        use_js_extensions: bool,
    ) -> Self {
        Self {
            interfaces,
            enums,
            use_js_extensions,
        }
    }

    pub fn generate_validators(
        &self,
        validator_functions: &[ValidatorFunction],
        output_file_path: &str,
    ) -> String {
        let mut output = String::new();

        // Add header comment
        output.push_str("// THIS FILE IS AUTO-GENERATED BY BAGSAKAN\n");
        output.push_str("// DO NOT EDIT THIS FILE MANUALLY\n");
        output.push_str("// To regenerate, run: bagsakan\n\n");

        // Deduplicate validator functions by name
        let mut seen = HashSet::new();
        let mut validators: Vec<_> = validator_functions
            .iter()
            .filter(|vf| seen.insert(&vf.name))
            .filter_map(|vf| {
                self.interfaces
                    .get(&vf.interface_name)
                    .map(|interface| (vf, interface))
            })
            .collect();

        validators.sort_by(|a, b| a.0.name.cmp(&b.0.name));

        // Generate imports
        let imports = self.generate_imports(&validators, output_file_path);
        if !imports.is_empty() {
            output.push_str(&imports);
            output.push_str("\n\n");
        }

        // Generate validators
        for (i, (validator, interface)) in validators.iter().enumerate() {
            if i > 0 {
                output.push_str("\n\n");
            }
            output.push_str(&self.generate_validator(&validator.name, interface));
        }

        output
    }

    fn generate_imports(
        &self,
        validators: &[(&ValidatorFunction, &InterfaceInfo)],
        output_file_path: &str,
    ) -> String {
        use std::collections::{HashMap, HashSet};
        use std::path::Path;

        let output_path = Path::new(output_file_path);
        let output_dir = output_path.parent().unwrap_or(Path::new(""));

        // Group interfaces by source file
        let mut imports_by_file: HashMap<String, HashSet<String>> = HashMap::new();

        // Collect all referenced types
        let mut referenced_types = HashSet::new();
        for (_, interface) in validators {
            referenced_types.insert(interface.name.clone());

            // Check properties for referenced types
            for prop in &interface.properties {
                self.collect_referenced_types(&prop.type_annotation, &mut referenced_types);
            }
        }

        // Group interfaces by their source files
        for interface_name in &referenced_types {
            if let Some(interface) = self.interfaces.get(interface_name) {
                let source_path = Path::new(&interface.file_path);
                let source_path_str = source_path.to_string_lossy();

                // Check if this is an external package or a local file
                let import_path = if source_path_str.contains("node_modules") {
                    // For node_modules, extract the package import path
                    // Look for pattern like "node_modules/package-name/path/to/file"
                    if let Some(pos) = source_path_str.find("node_modules/") {
                        let after_node_modules = &source_path_str[pos + 13..]; // Skip "node_modules/"

                        // Clean up any ./ prefix in the path
                        let cleaned = after_node_modules.replace("/./", "/");

                        // Remove file extension (.d.ts, .ts, .js, etc)
                        let without_ext = if cleaned.ends_with(".d.ts") {
                            &cleaned[..cleaned.len() - 5]
                        } else if let Some(dot_pos) = cleaned.rfind('.') {
                            &cleaned[..dot_pos]
                        } else {
                            &cleaned[..]
                        };

                        // Handle scoped packages and regular packages
                        let parts: Vec<&str> = without_ext.split('/').collect();
                        if parts.is_empty() {
                            // Fallback to relative path
                            self.calculate_relative_import_path(source_path, output_dir)
                        } else if parts[0].starts_with('@') && parts.len() > 2 {
                            // Scoped package like @org/package/subpath
                            format!("{}/{}", parts[0], parts[1..].join("/"))
                        } else if parts.len() > 1 {
                            // Regular package like package/subpath
                            parts.join("/")
                        } else {
                            // Just the package name
                            parts[0].to_string()
                        }
                    } else {
                        // Fallback to relative path
                        self.calculate_relative_import_path(source_path, output_dir)
                    }
                } else {
                    // Check if the path is outside the current working directory
                    // This handles symlinked packages and monorepo scenarios
                    let cwd = std::env::current_dir().unwrap_or_default();
                    if !source_path.starts_with(&cwd) {
                        // This is likely a symlinked package
                        // Try to extract package name from the path
                        // Look for common patterns like /lib/package-name/ or /packages/package-name/
                        let path_str = source_path_str.replace('\\', "/");

                        // Find package name by looking for common monorepo patterns
                        if let Some(package_match) = path_str.split('/').rev().find_map(|part| {
                            // Look for user-messaging-types or similar package names
                            if part.contains("-types") || part.contains("-api") {
                                Some(part)
                            } else {
                                None
                            }
                        }) {
                            // Found a package name, now extract the path within the package
                            if let Some(package_pos) =
                                path_str.rfind(&format!("/{}/", package_match))
                            {
                                let after_package =
                                    &path_str[package_pos + package_match.len() + 2..];

                                // Remove file extension and src/ prefix if present
                                let mut clean_path = after_package;
                                if clean_path.starts_with("src/") {
                                    clean_path = &clean_path[4..];
                                }

                                let without_ext = if clean_path.ends_with(".d.ts") {
                                    &clean_path[..clean_path.len() - 5]
                                } else if let Some(dot_pos) = clean_path.rfind('.') {
                                    &clean_path[..dot_pos]
                                } else {
                                    clean_path
                                };

                                // Add .js extension if configured
                                let import_specifier = if self.use_js_extensions {
                                    format!("{}.js", without_ext)
                                } else {
                                    without_ext.to_string()
                                };

                                format!("{}/{}", package_match, import_specifier)
                            } else {
                                // Fallback to relative path
                                self.calculate_relative_import_path(source_path, output_dir)
                            }
                        } else {
                            // Fallback to relative path
                            self.calculate_relative_import_path(source_path, output_dir)
                        }
                    } else {
                        // For local files within the project, use relative path
                        self.calculate_relative_import_path(source_path, output_dir)
                    }
                };

                imports_by_file
                    .entry(import_path)
                    .or_insert_with(HashSet::new)
                    .insert(interface_name.clone());
            }
        }

        // Generate import statements
        let mut imports = Vec::new();
        for (file, types) in imports_by_file {
            let mut type_list: Vec<_> = types.into_iter().collect();
            type_list.sort();
            imports.push(format!(
                "import type {{ {} }} from '{}';",
                type_list.join(", "),
                file
            ));
        }
        imports.sort();

        imports.join("\n")
    }

    fn calculate_relative_import_path(&self, source_path: &Path, output_dir: &Path) -> String {
        // Calculate relative path from output file to source file
        let relative_path = if let Some(rel) = pathdiff::diff_paths(source_path, output_dir) {
            rel
        } else {
            source_path.to_path_buf()
        };

        // Convert to import path (remove extension and use forward slashes)
        let mut import_path = relative_path.to_string_lossy().replace('\\', "/");

        // Remove extension (.ts, .tsx, .d.ts, etc)
        if let Some(pos) = import_path.rfind('.') {
            import_path = import_path[..pos].to_string();
        } else {
            import_path = import_path.to_string();
        }

        // Add ./ prefix if not already present
        if !import_path.starts_with("./") && !import_path.starts_with("../") {
            import_path = format!("./{}", import_path);
        }

        // Add .js extension if configured
        if self.use_js_extensions {
            import_path.push_str(".js");
        }

        import_path
    }

    fn collect_referenced_types(&self, type_str: &str, referenced_types: &mut HashSet<String>) {
        if type_str.ends_with("[]") {
            let element_type = &type_str[..type_str.len() - 2];
            self.collect_referenced_types(element_type, referenced_types);
        } else if type_str.contains(" | ") {
            for t in type_str.split(" | ") {
                if !t.starts_with('\'') {
                    self.collect_referenced_types(t, referenced_types);
                }
            }
        } else if self.interfaces.contains_key(type_str) {
            referenced_types.insert(type_str.to_string());
        }
    }

    fn generate_validator(&self, function_name: &str, interface: &InterfaceInfo) -> String {
        let mut body = String::new();

        body.push_str(&format!(
            "export function {}(value: unknown): value is {} {{\n",
            function_name, interface.name
        ));
        body.push_str("  if (typeof value !== 'object' || value === null) {\n");
        body.push_str("    return false;\n");
        body.push_str("  }\n\n");
        body.push_str(&format!("  const obj = value as {};\n", interface.name));

        for prop in &interface.properties {
            body.push_str(&self.generate_property_check(prop));
        }

        body.push_str("  return true;\n");
        body.push_str("}");

        body
    }

    fn generate_property_check(&self, prop: &PropertyInfo) -> String {
        let mut check = String::new();
        let validation =
            self.get_inline_validation(&prop.type_annotation, &format!("obj.{}", prop.name));

        if prop.optional {
            // For optional properties, combine the undefined check with type validation
            let needs_complex_check = !matches!(
                prop.type_annotation.as_str(),
                "string" | "number" | "boolean" | "null" | "undefined"
            ) && !prop.type_annotation.starts_with('\'')
                && !prop.type_annotation.contains(" | ");
            if needs_complex_check {
                // Check if validation already has outer parentheses
                let wrapped_validation = if validation.starts_with('(') && validation.ends_with(')')
                {
                    format!("!{}", validation)
                } else {
                    format!("!({})", validation)
                };
                check.push_str(&format!(
                    "  if (obj.{} !== undefined && {}) {{\n",
                    prop.name, wrapped_validation
                ));
            } else {
                let negated_validation = self
                    .get_negated_validation(&prop.type_annotation, &format!("obj.{}", prop.name));
                check.push_str(&format!(
                    "  if (obj.{} !== undefined && {}) {{\n",
                    prop.name, negated_validation
                ));
            }
            check.push_str("    return false;\n");
            check.push_str("  }\n");
        } else {
            // For required properties, we can skip the 'in' check if the type check would fail for undefined
            let needs_in_check = self.type_allows_undefined(&prop.type_annotation);

            if needs_in_check {
                // Check if validation already has outer parentheses
                let wrapped_validation = if validation.starts_with('(') && validation.ends_with(')')
                {
                    format!("!{}", validation)
                } else {
                    format!("!({})", validation)
                };
                check.push_str(&format!(
                    "  if (!('{}' in obj) || {}) {{\n",
                    prop.name, wrapped_validation
                ));
            } else {
                // For simple type checks, we can negate directly
                let negated_validation = self
                    .get_negated_validation(&prop.type_annotation, &format!("obj.{}", prop.name));
                check.push_str(&format!("  if ({}) {{\n", negated_validation));
            }
            check.push_str("    return false;\n");
            check.push_str("  }\n");
        }

        check
    }

    fn get_inline_validation(&self, type_str: &str, value_expr: &str) -> String {
        match type_str {
            "string" => format!("typeof {} === 'string'", value_expr),
            "number" => format!("typeof {} === 'number'", value_expr),
            "boolean" => format!("typeof {} === 'boolean'", value_expr),
            "any" => "true".to_string(),
            "void" => format!("{} === undefined", value_expr),
            "null" => format!("{} === null", value_expr),
            "undefined" => format!("{} === undefined", value_expr),
            _ if type_str.ends_with("[]") => {
                let element_type = &type_str[..type_str.len() - 2];
                if self.is_simple_type(element_type) {
                    let element_check = self.get_simple_type_check(element_type);
                    format!(
                        "(Array.isArray({}) && {}.every({}))",
                        value_expr, value_expr, element_check
                    )
                } else {
                    format!(
                        "(Array.isArray({}) && {}.every(validate{}))",
                        value_expr, value_expr, element_type
                    )
                }
            }
            _ if type_str.contains(" | ") => {
                let types: Vec<&str> = type_str.split(" | ").collect();
                let checks: Vec<String> = types
                    .iter()
                    .map(|t| {
                        if t.starts_with('\'') && t.ends_with('\'') {
                            format!("{} === {}", value_expr, t)
                        } else {
                            self.get_inline_validation(t, value_expr)
                        }
                    })
                    .collect();
                format!("({})", checks.join(" || "))
            }
            _ if type_str.starts_with('\'') && type_str.ends_with('\'') => {
                format!("({} === {})", value_expr, type_str)
            }
            _ => {
                // Check for known built-in types
                match type_str {
                    "Date" => format!("{} instanceof Date", value_expr),
                    "Record" => format!(
                        "typeof {} === 'object' && {} !== null",
                        value_expr, value_expr
                    ),
                    _ => {
                        // Check for generic types like Record<K, V>
                        if type_str.starts_with("Record<") && type_str.ends_with(">") {
                            format!(
                                "typeof {} === 'object' && {} !== null",
                                value_expr, value_expr
                            )
                        } else if self.interfaces.contains_key(type_str) {
                            format!("validate{}({})", type_str, value_expr)
                        } else if let Some(enum_info) = self.enums.get(type_str) {
                            // Generate enum validation
                            self.generate_enum_validation(enum_info, value_expr)
                        } else {
                            // Unknown type - be conservative and check it's not undefined
                            format!("{} !== undefined", value_expr)
                        }
                    }
                }
            }
        }
    }

    fn generate_enum_validation_negated(&self, enum_info: &EnumInfo, value_expr: &str) -> String {
        // Generate validation that returns true when the value is NOT a valid enum member
        let mut numeric_values: Vec<i64> = Vec::new();
        let mut string_checks: Vec<String> = Vec::new();

        for member in &enum_info.members {
            match &member.value {
                EnumValue::Number(n) => {
                    if n.fract() == 0.0 {
                        numeric_values.push(*n as i64);
                    }
                }
                EnumValue::String(s) => {
                    string_checks.push(format!("{} !== '{}'", value_expr, s));
                }
                EnumValue::Computed => {}
            }
        }

        let mut checks: Vec<String> = Vec::new();

        // Handle numeric values
        if !numeric_values.is_empty() {
            numeric_values.sort();

            let mut i = 0;
            while i < numeric_values.len() {
                let start = numeric_values[i];
                let mut end = start;

                // Find consecutive sequence
                while i + 1 < numeric_values.len() && numeric_values[i + 1] == end + 1 {
                    end = numeric_values[i + 1];
                    i += 1;
                }

                // Use range if we have 3 or more consecutive values
                if end - start >= 2 {
                    // Range checks don't need extra parentheses
                    checks.push(format!(
                        "{} < {} || {} > {}",
                        value_expr, start, value_expr, end
                    ));
                } else {
                    // Use individual checks for small ranges
                    for val in start..=end {
                        checks.push(format!("{} !== {}", value_expr, val));
                    }
                }

                i += 1;
            }
        }

        // Add string checks
        checks.extend(string_checks);

        if checks.is_empty() {
            format!("{} === undefined", value_expr)
        } else if checks.len() == 1 {
            checks[0].clone()
        } else {
            // Use AND because all conditions must be true for invalid value
            // Join without wrapping in parentheses - they'll be added by the if statement
            checks.join(" && ")
        }
    }

    fn generate_enum_validation(&self, enum_info: &EnumInfo, value_expr: &str) -> String {
        // Collect numeric and string values separately
        let mut numeric_values: Vec<i64> = Vec::new();
        let mut string_values: Vec<String> = Vec::new();

        for member in &enum_info.members {
            match &member.value {
                EnumValue::Number(n) => {
                    // Convert to i64 for integer comparison
                    if n.fract() == 0.0 {
                        numeric_values.push(*n as i64);
                    }
                }
                EnumValue::String(s) => {
                    string_values.push(format!("{} === '{}'", value_expr, s));
                }
                EnumValue::Computed => {} // Skip computed values
            }
        }

        let mut checks: Vec<String> = Vec::new();

        // Handle numeric values - look for consecutive ranges
        if !numeric_values.is_empty() {
            numeric_values.sort();

            let mut i = 0;
            while i < numeric_values.len() {
                let start = numeric_values[i];
                let mut end = start;

                // Find consecutive sequence
                while i + 1 < numeric_values.len() && numeric_values[i + 1] == end + 1 {
                    end = numeric_values[i + 1];
                    i += 1;
                }

                // Use range if we have 3 or more consecutive values
                if end - start >= 2 {
                    checks.push(format!(
                        "{} >= {} && {} <= {}",
                        value_expr, start, value_expr, end
                    ));
                } else {
                    // Use individual checks for small ranges
                    for val in start..=end {
                        checks.push(format!("{} === {}", value_expr, val));
                    }
                }

                i += 1;
            }
        }

        // Add string value checks
        checks.extend(string_values);

        if checks.is_empty() {
            // If all enum values are computed, fall back to basic check
            format!("{} !== undefined", value_expr)
        } else if checks.len() == 1 {
            // Single check doesn't need wrapping parentheses
            checks[0].clone()
        } else {
            // Multiple checks need parentheses for grouping
            format!("({})", checks.join(" || "))
        }
    }

    fn is_simple_type(&self, type_str: &str) -> bool {
        matches!(
            type_str,
            "string" | "number" | "boolean" | "any" | "void" | "null" | "undefined"
        )
    }

    fn type_allows_undefined(&self, type_str: &str) -> bool {
        // Check if a type could be undefined or contain undefined
        if type_str == "any"
            || type_str == "undefined"
            || type_str == "void"
            || type_str == "unknown"
        {
            return true;
        }

        // Check union types
        if type_str.contains(" | ") {
            return type_str
                .split(" | ")
                .any(|t| self.type_allows_undefined(t.trim()));
        }

        // For array types, undefined is not allowed
        if type_str.ends_with("[]") {
            return false;
        }

        // For literal types, undefined is not allowed
        if type_str.starts_with('\'') && type_str.ends_with('\'') {
            return false;
        }

        // For basic types and custom types, undefined is not allowed
        false
    }

    fn get_negated_validation(&self, type_str: &str, value_expr: &str) -> String {
        match type_str {
            "string" => format!("typeof {} !== 'string'", value_expr),
            "number" => format!("typeof {} !== 'number'", value_expr),
            "boolean" => format!("typeof {} !== 'boolean'", value_expr),
            "null" => format!("{} !== null", value_expr),
            "undefined" => format!("{} !== undefined", value_expr),
            _ if type_str.starts_with('\'') && type_str.ends_with('\'') => {
                // Handle string literals
                format!("{} !== {}", value_expr, type_str)
            }
            _ => {
                // Check if it's a union type
                if type_str.contains(" | ") {
                    let types: Vec<&str> = type_str.split(" | ").collect();
                    let checks: Vec<String> = types
                        .iter()
                        .map(|t| {
                            if t.starts_with('\'') && t.ends_with('\'') {
                                format!("{} !== {}", value_expr, t)
                            } else {
                                self.get_negated_validation(t, value_expr)
                            }
                        })
                        .collect();
                    if checks.len() == 1 {
                        checks[0].clone()
                    } else {
                        checks.join(" && ")
                    }
                } else if let Some(enum_info) = self.enums.get(type_str) {
                    // Check if it's an enum type
                    self.generate_enum_validation_negated(enum_info, value_expr)
                } else {
                    // For complex types, fall back to negating the validation
                    let validation = self.get_inline_validation(type_str, value_expr);
                    // Check if validation already has outer parentheses
                    if validation.starts_with('(') && validation.ends_with(')') {
                        format!("!{}", validation)
                    } else {
                        format!("!({})", validation)
                    }
                }
            }
        }
    }

    fn get_simple_type_check(&self, type_str: &str) -> String {
        match type_str {
            "string" => "(v: any) => typeof v === 'string'".to_string(),
            "number" => "(v: any) => typeof v === 'number'".to_string(),
            "boolean" => "(v: any) => typeof v === 'boolean'".to_string(),
            "any" => "() => true".to_string(),
            "void" => "(v: any) => v === undefined".to_string(),
            "null" => "(v: any) => v === null".to_string(),
            "undefined" => "(v: any) => v === undefined".to_string(),
            _ => "() => true".to_string(),
        }
    }

    pub fn write_to_file(
        &self,
        path: &Path,
        content: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }
        fs::write(path, content)?;
        Ok(())
    }
}
